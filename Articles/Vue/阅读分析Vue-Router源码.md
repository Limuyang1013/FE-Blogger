#### è·¯ç”±çš„æ¦‚å¿µ
è·¯ç”±è¿™ä¸ªæ¦‚å¿µæœ€å¼€å§‹æ˜¯åœ¨åç«¯å‡ºç°çš„ï¼Œä»¥å‰ä½¿ç”¨æ¨¡æ¿å¼•æ“å¼€å‘é¡µé¢çš„æ—¶å€™ç»å¸¸ä¼šçœ‹åˆ°è¿™æ ·çš„è·¯å¾„ï¼š
```
http://hometown.xxx.edu.cn/bbs/forum.php
```
æœ‰æ—¶è¿˜ä¼šæœ‰å¸¦.aspæˆ–.htmlçš„è·¯å¾„ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„SSR(Server Side Render)ï¼Œé€šè¿‡æœåŠ¡ç«¯æ¸²æŸ“ï¼Œç›´æ¥è¿”å›é¡µé¢ã€‚

å…¶å“åº”è¿‡ç¨‹æ˜¯è¿™æ ·çš„

1.æµè§ˆå™¨å‘å‡ºè¯·æ±‚

2.æœåŠ¡å™¨ç›‘å¬åˆ°80ç«¯å£ï¼ˆæˆ–443ï¼‰æœ‰è¯·æ±‚è¿‡æ¥ï¼Œå¹¶è§£æurlè·¯å¾„

3.æ ¹æ®æœåŠ¡å™¨çš„è·¯ç”±é…ç½®ï¼Œè¿”å›ç›¸åº”ä¿¡æ¯ï¼ˆå¯ä»¥æ˜¯ html å­—ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯ json æ•°æ®ï¼Œå›¾ç‰‡ç­‰ï¼‰

4.æµè§ˆå™¨æ ¹æ®æ•°æ®åŒ…çš„Content-Typeæ¥å†³å®šå¦‚ä½•è§£ææ•°æ®

ç®€å•æ¥è¯´è·¯ç”±å°±æ˜¯ç”¨æ¥è·Ÿåç«¯æœåŠ¡å™¨è¿›è¡Œäº¤äº’çš„ä¸€ç§æ–¹å¼ï¼Œé€šè¿‡ä¸åŒçš„è·¯å¾„ï¼Œæ¥è¯·æ±‚ä¸åŒçš„èµ„æºï¼Œè¯·æ±‚ä¸åŒçš„é¡µé¢æ˜¯è·¯ç”±çš„å…¶ä¸­ä¸€ç§åŠŸèƒ½ã€‚å°±åƒè·¯ç”±å™¨åœ¨ç½‘ç»œå±‚ä¸­æ‰®æ¼”çš„è§’è‰²ä¸€æ ·ï¼Œè‚©è´Ÿç€å°†æ•°æ®åŒ…æ­£ç¡®å¯¼å‘ç›®çš„åœ°å€çš„é‡ä»»ï¼Œåªä¸è¿‡åœ¨è¿™é‡Œå˜æˆäº†å®¢æˆ·ç«¯æµè§ˆå™¨çš„æŒ‡è·¯äººï¼Œæ‰€è°“çš„å‰ç«¯è·¯ç”±ï¼ŒæŒ‡çš„æ˜¯ä¸€ç§èƒ½åŠ›ï¼Œå³ï¼š
> ä¸ä¾èµ–äºæœåŠ¡å™¨ï¼Œæ ¹æ®ä¸åŒçš„URLæ¸²æŸ“ä¸åŒçš„é¡µé¢

#### å‰ç«¯è·¯ç”±ä¸åç«¯è·¯ç”±
åœ¨`Ajax`è¿˜æ²¡æœ‰è¯ç”Ÿçš„æ—¶å€™ï¼Œè·¯ç”±çš„å·¥ä½œæ˜¯äº¤ç»™åç«¯æ¥å®Œæˆçš„ï¼Œå½“è¿›è¡Œé¡µé¢åˆ‡æ¢çš„æ—¶å€™ï¼Œæµè§ˆå™¨ä¼šå‘é€ä¸åŒçš„`URL`è¯·æ±‚ï¼ŒæœåŠ¡å™¨æ¥æ”¶åˆ°æµè§ˆå™¨çš„è¯·æ±‚æ—¶ï¼Œé€šè¿‡è§£æä¸åŒçš„`URL`å»æ‹¼æ¥éœ€è¦çš„`Html`æˆ–æ¨¡æ¿ï¼Œç„¶åå°†ç»“æœè¿”å›åˆ°æµè§ˆå™¨ç«¯è¿›è¡Œæ¸²æŸ“ã€‚

æœåŠ¡å™¨ç«¯è·¯ç”±åŒæ ·æ˜¯æœ‰åˆ©äº¦æœ‰å¼Šã€‚å®ƒçš„å¥½å¤„æ˜¯å®‰å…¨æ€§æ›´é«˜ï¼Œæ›´ä¸¥æ ¼å¾—æ§åˆ¶é¡µé¢çš„å±•ç°ã€‚è¿™åœ¨æŸäº›åœºæ™¯ä¸­æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œè­¬å¦‚ä¸‹å•æ”¯ä»˜æµç¨‹ï¼Œæ¯ä¸€æ­¥åªæœ‰åœ¨ä¸Šä¸€æ­¥æˆåŠŸæ‰§è¡Œä¹‹åæ‰èƒ½æŠµè¾¾ã€‚è¿™åœ¨æœåŠ¡å™¨ç«¯å¯ä»¥ä¸ºæ¯ä¸€æ­¥æµç¨‹æ·»åŠ éªŒè¯æœºåˆ¶ï¼Œåªæœ‰éªŒè¯é€šè¿‡æ‰è¿”å›æ­£ç¡®çš„é¡µé¢ã€‚é‚£ä¹ˆå‰ç«¯è·¯ç”±ä¸èƒ½å®ç°æ¯ä¸€æ­¥çš„éªŒè¯ï¼Ÿè‡ªç„¶ä¸æ˜¯ï¼Œå§‘ä¸”ç›¸ä¿¡ä½ çš„ä»£ç å¯ä»¥å†™çš„å¾ˆä¸¥è°¨ï¼Œä¿è¯æ­£å¸¸æƒ…å†µä¸‹æµç¨‹ä¸ä¼šé”™ï¼Œä½†æ˜¯å¦ä¸€ä¸ªä¸å¾—ä¸é¢å¯¹çš„äº‹å®æ˜¯ï¼šå‰ç«¯æ˜¯æ¯«æ— å®‰å…¨æ€§å¯è¨€çš„ã€‚ç”¨æˆ·å¯ä»¥è‚†æ„ä¿®æ”¹ä»£ç æ¥è¿›å…¥ä¸åŒçš„æµç¨‹ï¼Œä½ å¯èƒ½ä¼šä¸ºæ­¤æ·»åŠ ä¸å°‘çš„å¤„ç†é€»è¾‘ã€‚ç›¸è¾ƒä¹‹ä¸‹ï¼Œå½“ç„¶æ˜¯åç«¯æ§åˆ¶é¡µé¢çš„è¿›å…¥æƒé™æ›´ä¸ºå®‰å…¨å’Œç®€ä¾¿ã€‚

å¦ä¸€æ–¹é¢ï¼Œåç«¯è·¯ç”±æ— ç–‘å¢åŠ äº†æœåŠ¡å™¨ç«¯çš„è´Ÿè·ï¼Œå¹¶ä¸”éœ€è¦reloadé¡µé¢ï¼Œç”¨æˆ·ä½“éªŒå…¶å®ä¸ä½³ã€‚

#### å‰ç«¯è·¯ç”±çš„å‡ºç°
åœ¨ 90s å¹´ä»£åˆï¼Œå¤§å¤šæ•°çš„ç½‘é¡µéƒ½æ˜¯é€šè¿‡ç›´æ¥è¿”å›`HTML`çš„ï¼Œç”¨æˆ·çš„æ¯æ¬¡æ›´æ–°æ“ä½œéƒ½éœ€è¦é‡æ–°åˆ·æ–°é¡µé¢ã€‚åŠå…¶å½±å“äº¤äº’ä½“éªŒï¼Œéšç€ç½‘ç»œçš„å‘å±•ï¼Œè¿«åˆ‡éœ€è¦ä¸€ç§æ–¹æ¡ˆæ¥æ”¹å–„è¿™ç§æƒ…å†µã€‚

1996ï¼Œå¾®è½¯é¦–å…ˆæå‡º iframe æ ‡ç­¾ï¼Œ`iframe`å¸¦æ¥äº†å¼‚æ­¥åŠ è½½å’Œè¯·æ±‚å…ƒç´ çš„æ¦‚å¿µï¼Œéšååœ¨ 1998 å¹´ï¼Œå¾®è½¯çš„ Outloook Web App å›¢é˜Ÿæå‡º`Ajax`çš„åŸºæœ¬æ¦‚å¿µï¼ˆXMLHttpRequestçš„å‰èº«ï¼‰ï¼Œå¹¶åœ¨`IE5`é€šè¿‡`ActiveX`æ¥å®ç°äº†è¿™é¡¹æŠ€æœ¯ã€‚åœ¨å¾®è½¯å®ç°è¿™ä¸ªæ¦‚å¿µåï¼Œå…¶ä»–æµè§ˆå™¨æ¯”å¦‚`Mozilia`ï¼Œ`Safari`ï¼Œ`Opera`ç›¸ç»§ä»¥ `XMLHttpRequest`æ¥å®ç°`Ajax`ã€‚ï¼ˆğŸ˜­ å…¼å®¹é—®é¢˜ä»æ­¤å‡ºç°ï¼Œè¯è¯´å¾®è½¯å‘½åçœŸå–œæ¬¢ç”¨Xï¼ŒMFCæºç ä¸€å¤§å †ã€‚ã€‚ï¼‰ä¸è¿‡åœ¨ IE7 å‘å¸ƒæ—¶ï¼Œå¾®è½¯é€‰æ‹©äº†å¦¥åï¼Œå…¼å®¹äº†`XMLHttpRequest`çš„å®ç°ã€‚

æœ‰äº†`Ajax`åï¼Œç”¨æˆ·äº¤äº’å°±ä¸ç”¨æ¯æ¬¡éƒ½åˆ·æ–°é¡µé¢ï¼Œä½“éªŒå¸¦æ¥äº†æå¤§çš„æå‡ã€‚

ä½†çœŸæ­£è®©è¿™é¡¹æŠ€æœ¯å‘æ‰¬å…‰å¤§çš„ï¼Œ(ï½¡ï½¥âˆ€ï½¥)ï¾‰ï¾è¿˜æ˜¯åæ¥çš„ Google Mapï¼Œå®ƒçš„å‡ºç°å‘äººä»¬å±•ç°äº†`Ajax`çš„çœŸæ­£é­…åŠ›ï¼Œé‡Šæ”¾äº†ä¼—å¤šå¼€å‘äººå‘˜çš„æƒ³è±¡åŠ›ï¼Œè®©å…¶ä¸ä»…ä»…å±€é™äºç®€å•çš„æ•°æ®å’Œé¡µé¢äº¤äº’ï¼Œä¸ºåæ¥å¼‚æ­¥äº¤äº’ä½“éªŒæ–¹å¼çš„ç¹è£å‘å±•å¸¦æ¥äº†æ ¹åŸºã€‚

è€Œå¼‚æ­¥äº¤äº’ä½“éªŒçš„æ›´é«˜çº§ç‰ˆæœ¬å°±æ˜¯æˆ‘ä»¬ç†ŸçŸ¥çš„`SPA`ï¼Œ`SPA`ä¸å•å•åœ¨é¡µé¢äº¤äº’ä¸Šåšåˆ°äº†ä¸åˆ·æ–°ï¼Œè€Œä¸”åœ¨é¡µé¢ä¹‹é—´è·³è½¬ä¹Ÿåšåˆ°äº†ä¸åˆ·æ–°ï¼Œä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œå°±ä¿ƒä½¿äº†å‰ç«¯è·¯ç”±çš„è¯ç”Ÿã€‚

#### å‰ç«¯è·¯ç”±çš„å®ç°æ–¹å¼
å‰ç«¯è·¯ç”±å…¶å®åªè¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š
- åœ¨é¡µé¢ä¸åˆ·æ–°çš„å‰æä¸‹å®ç°urlå˜åŒ–
- æ•æ‰åˆ°urlçš„å˜åŒ–ï¼Œä»¥ä¾¿æ‰§è¡Œé¡µé¢æ›¿æ¢é€»è¾‘
åœ¨ 2014 å¹´ä¹‹å‰ï¼Œå¤§å®¶æ˜¯é€šè¿‡ hash æ¥å®ç°è·¯ç”±ï¼Œurl hash å°±æ˜¯ç±»ä¼¼äºï¼š
```
http://www.xxx.com/#/login

```
è¿™ç§ #ã€‚åé¢`hash`å€¼çš„å˜åŒ–ï¼Œå¹¶ä¸ä¼šå¯¼è‡´æµè§ˆå™¨å‘æœåŠ¡å™¨å‘å‡ºè¯·æ±‚ï¼Œæµè§ˆå™¨ä¸å‘å‡ºè¯·æ±‚ï¼Œä¹Ÿå°±ä¸ä¼šåˆ·æ–°é¡µé¢ã€‚å¦å¤–æ¯æ¬¡`hash`å€¼çš„å˜åŒ–ï¼Œè¿˜ä¼šè§¦å‘`hashchange`è¿™ä¸ªäº‹ä»¶ï¼Œé€šè¿‡è¿™ä¸ªäº‹ä»¶æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“`hash`å€¼å‘ç”Ÿäº†å“ªäº›å˜åŒ–ã€‚ç„¶åæˆ‘ä»¬ä¾¿å¯ä»¥ç›‘å¬`hashchange`æ¥å®ç°æ›´æ–°é¡µé¢éƒ¨åˆ†å†…å®¹çš„æ“ä½œï¼š

```javascript
function matchAndUpdate () {
   // todo åŒ¹é… hash åš dom æ›´æ–°æ“ä½œ
}
window.addEventListener('hashchange', matchAndUpdate)

```
åæ¥ï¼Œå› ä¸º`HTML5`æ ‡å‡†å‘å¸ƒã€‚å¤šäº†ä¸¤ä¸ª APIï¼Œ`pushState`å’Œ`replaceState`ï¼Œé€šè¿‡è¿™ä¸¤ä¸ª`API`å¯ä»¥æ”¹å˜ `url`åœ°å€ä¸”ä¸ä¼šå‘é€è¯·æ±‚ã€‚åŒæ—¶è¿˜æœ‰`popstate`äº‹ä»¶ã€‚é€šè¿‡è¿™äº›å°±èƒ½ç”¨å¦ä¸€ç§æ–¹å¼æ¥å®ç°å‰ç«¯è·¯ç”±äº†ï¼Œä½†åŸç†éƒ½æ˜¯è·Ÿ`hash`å®ç°ç›¸åŒçš„ã€‚ç”¨äº†`HTML5`çš„å®ç°ï¼Œå•é¡µè·¯ç”±çš„`url`å°±ä¸ä¼šå¤šå‡ºä¸€ä¸ª#ï¼Œå˜å¾—æ›´åŠ ç¾è§‚ã€‚ä½†å› ä¸ºæ²¡æœ‰ # å·ï¼Œæ‰€ä»¥å½“ç”¨æˆ·åˆ·æ–°é¡µé¢ä¹‹ç±»çš„æ“ä½œæ—¶ï¼Œæµè§ˆå™¨è¿˜æ˜¯ä¼šç»™æœåŠ¡å™¨å‘é€è¯·æ±‚ã€‚ä¸ºäº†é¿å…å‡ºç°è¿™ç§æƒ…å†µï¼Œæ‰€ä»¥è¿™ä¸ªå®ç°éœ€è¦æœåŠ¡å™¨çš„æ”¯æŒï¼Œéœ€è¦æŠŠæ‰€æœ‰è·¯ç”±éƒ½é‡å®šå‘åˆ°æ ¹é¡µé¢ï¼š

```javascript
function matchAndUpdate () {
   // todo åŒ¹é…è·¯å¾„ åš dom æ›´æ–°æ“ä½œ
}
window.addEventListener('popstate', matchAndUpdate)

```
#### Vue-Routerçš„å®ç°æ–¹å¼
`Vue-Router`è·Ÿ`Vuex`ä¸€æ ·éƒ½æ˜¯é€šè¿‡`Vue.use`è¿™ä¸ªå…¨å±€`API`æ¥æ³¨å†Œçš„ï¼Œè¿™ä¸ªæ–¹æ³•å®šä¹‰åœ¨`vue/src/core/global-api/use.js`ï¼š

```javascript
/* @flow */

import { toArray } from '../util/index'

export function initUse (Vue: GlobalAPI) {
  Vue.use = function (plugin: Function | Object) {
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    const args = toArray(arguments, 1)
    args.unshift(this)
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args)
    }
    installedPlugins.push(plugin)
    return this
  }
}
```
`Vue.use`æ¥å—ä¸€ä¸ª`plugin`å‚æ•°ï¼Œå¹¶ä¸”ç»´æŠ¤äº†ä¸€ä¸ª`_installedPlugins`æ•°ç»„ï¼Œå®ƒå­˜å‚¨æ‰€æœ‰æ³¨å†Œè¿‡çš„`plugin`ï¼›å¦‚æœ`plugin`æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä¼šåˆ¤æ–­`plugin`æœ‰æ²¡æœ‰å®šä¹‰`install`æ–¹æ³•ï¼Œå¦‚æœæœ‰çš„è¯åˆ™è°ƒç”¨è¯¥æ–¹æ³•ï¼Œå¹¶ä¸”è¯¥æ–¹æ³•æ‰§è¡Œçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯`Vue`ï¼›å¦‚æœ`plugin`æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒä¼šè¢«ä½œä¸º`install`æ–¹æ³•ï¼Œæœ€åæŠŠ`plugin`å­˜å‚¨åˆ°`installedPlugins`æ•°ç»„é‡Œé¢ï¼Œ`Vue`çš„è¿™ç§æ’ä»¶æ³¨å†Œçš„æœºåˆ¶æœ‰ä¸€ä¸ªå¥½å¤„å°±æ˜¯æˆ‘ä»¬ä¸éœ€è¦é¢å¤–çš„å»`import Vue`äº†ã€‚

##### è·¯ç”±çš„æ³¨å†Œ
`Vue-Router`çš„å…¥å£åœ¨`src/index.js`ï¼Œå…¶ä¸­`install`æ–¹æ³•å®šä¹‰åœ¨`src/install.js`ï¼Œå¯ä»¥çœ‹ä¸€ä¸‹`src`ä¸‹é¢çš„ç›®å½•ç»“æ„ï¼š

```
â”œâ”€â”€ components
â”‚Â Â  â”œâ”€â”€ link.js
â”‚Â Â  â””â”€â”€ view.js
â”œâ”€â”€ create-matcher.js
â”œâ”€â”€ create-route-map.js
â”œâ”€â”€ history
â”‚Â Â  â”œâ”€â”€ abstract.js
â”‚Â Â  â”œâ”€â”€ base.js
â”‚Â Â  â”œâ”€â”€ hash.js
â”‚Â Â  â””â”€â”€ html5.js
â”œâ”€â”€ index.js
â”œâ”€â”€ install.js
â””â”€â”€ util
    â”œâ”€â”€ async.js
    â”œâ”€â”€ dom.js
    â”œâ”€â”€ location.js
    â”œâ”€â”€ misc.js
    â”œâ”€â”€ params.js
    â”œâ”€â”€ path.js
    â”œâ”€â”€ push-state.js
    â”œâ”€â”€ query.js
    â”œâ”€â”€ resolve-components.js
    â”œâ”€â”€ route.js
    â”œâ”€â”€ scroll.js
    â””â”€â”€ warn.js

```
ç®€å•çœ‹ä¸‹`install`çš„æµç¨‹ï¼š

```javascript
import View from './components/view'
import Link from './components/link'

export let _Vue

export function install (Vue) {
  // ç¡®ä¿Vue-Routeråªè¢«installä¸€æ¬¡
  if (install.installed && _Vue === Vue) return
  install.installed = true

  _Vue = Vue

  const isDef = v => v !== undefined

  const registerInstance = (vm, callVal) => {
    let i = vm.$options._parentVnode
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal)
    }
  }

  Vue.mixin({
    // åœ¨beforeCreateé’©å­é‡Œé¢åˆå§‹åŒ–è·¯ç”±
    beforeCreate () {
      // æ ¹ç»„ä»¶çš„$optionsä¸Šæ‰æœ‰routerå¯¹è±¡
      if (isDef(this.$options.router)) {
        // è®¾ç½®æ ¹è·¯ç”±
        this._routerRoot = this
        // è·å–åˆ°æ ¹ç»„ä»¶ä¸Šçš„routerå®ä¾‹
        this._router = this.$options.router
        // è·¯ç”±åˆå§‹åŒ–
        this._router.init(this)
        // ä¸º_routeå±æ€§å®ç°åŒå‘ç»‘å®š
        Vue.util.defineReactive(this, '_route', this._router.history.current)
      } else {
        // è·å–çˆ¶ç»„ä»¶çš„_routerRoot
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this
      }
      // æ³¨å†Œ<router-view></router-view>å®ä¾‹çš„é’©å­
      registerInstance(this, this)
    },
    destroyed () {
      registerInstance(this)
    }
  })
  // æ–¹ä¾¿å…¨å±€é€šè¿‡this.$routerè·å–è·¯ç”±å®ä¾‹
  Object.defineProperty(Vue.prototype, '$router', {
    get () { return this._routerRoot._router }
  })
  // æ–¹ä¾¿å…¨å±€é€šè¿‡this.$routeè·å–è·¯ç”±å¯¹è±¡
  Object.defineProperty(Vue.prototype, '$route', {
    get () { return this._routerRoot._route }
  })
  // æ³¨å†Œå…¨å±€ç»„ä»¶<router-view/>å’Œ<router-link/>
  Vue.component('RouterView', View)
  Vue.component('RouterLink', Link)
  // ä½¿ç”¨å’Œcreatedç›¸åŒçš„åˆå¹¶ç­–ç•¥
  const strats = Vue.config.optionMergeStrategies
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created
}

```
é¦–å…ˆé€šè¿‡è®¾ç«‹ä¸€ä¸ª`installed`æ ‡å¿—ä½æ¥ç¡®ä¿`Vue-Router`åªè¢«å®‰è£…ä¸€æ¬¡ï¼Œç„¶åé€šè¿‡å˜é‡`_Vue`æ‰¿è½½ä¼ å…¥çš„`Vue`å®ä¾‹ï¼Œç„¶ååˆ©ç”¨`Vue.mixin`å‘æ¯ä¸€ä¸ª`Vue`å®ä¾‹æ³¨å†Œ`beforeCreate`å’Œ`destroyed`é’©å­å‡½æ•°ã€‚

åœ¨`beforeCreate`å‡½æ•°é‡Œé¢ï¼Œå¦‚æœæ˜¯æ ¹ç»„ä»¶ï¼Œå°†æ ¹ç»„ä»¶èµ‹å€¼ç»™`this._routerRoot`ï¼Œè·å–æ ¹ç»„ä»¶çš„è·¯ç”±å®ä¾‹ä¹‹åæ‰§è¡Œ`init`åˆå§‹åŒ–å‡½æ•°ï¼Œç„¶åè°ƒç”¨`Vue`çš„`defineReactive`å°†`_route`å˜ä¸ºå“åº”å¼å¯¹è±¡ï¼Œå¦‚æœä¸æ˜¯æ ¹ç»„ä»¶åˆ™è·å–çˆ¶ç»„ä»¶çš„`_routerRoot`å±æ€§ã€‚

åœ¨`beforeCreate`å‡½æ•°çš„æœ€åéƒ¨åˆ†å’Œ`destroyed`å‡½æ•°é‡Œé¢éƒ½æ‰§è¡Œäº†`registerInstance`å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯æ³¨å†Œ`<router-view>`å®ä¾‹çš„é’©å­å‡½æ•°ï¼Œæ ¹æ®ä¼ å…¥å‚æ•°çš„ä¸ªæ•°æ¥å†³å®šæ˜¯æ³¨å†Œè¿˜æ˜¯å–æ¶ˆæ³¨å†Œï¼Œå‡½æ•°çš„å®šä¹‰åœ¨`src/components/view.js`é‡Œé¢:

```javascript
   // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = (vm, val) => {
      // val could be undefined for unregistration
      const current = matched.instances[name]
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val
      }
    }
```
å›åˆ°`install.js`ï¼Œç´§æ¥ç€ï¼Œä¸ºäº†è®©æˆ‘ä»¬èƒ½å¤Ÿå…¨å±€çš„ä½¿ç”¨`this.$router`å’Œ`this.$route`åœ¨`Vue`åŸå‹ä¸Šå®šä¹‰äº†å¯¹åº”çš„`get`æ–¹æ³•ï¼Œç„¶åé€šè¿‡`Vue.component`æ³¨å†Œäº†å…¨å±€ç»„ä»¶`æ³¨å†Œå…¨å±€ç»„ä»¶<router-view/>`å’Œ`å’Œ<router-link/>`ï¼Œæœ€åå®šä¹‰äº†ä¸€äº›é’©å­å‡½æ•°çš„ä½¿ç”¨ç­–ç•¥ï¼Œè¿™å°±æ˜¯æ•´ä¸ª`Vue-Router`çš„å®‰è£…è¿‡ç¨‹ã€‚

##### è·¯ç”±çš„å®ä¾‹åŒ–
å…ˆçœ‹ä¸€ä¸‹`Vue-Router`çš„æ„é€ å‡½æ•°ï¼Œå½“æˆ‘ä»¬`new`ä¸€ä¸ª`Vue-Router`çš„æ—¶å€™éƒ½å¹²äº†äº›ä»€ä¹ˆï¼š

```javascript
/* @flow */

import { install } from './install'
import { START } from './util/route'
import { assert } from './util/warn'
import { inBrowser } from './util/dom'
import { cleanPath } from './util/path'
import { createMatcher } from './create-matcher'
import { normalizeLocation } from './util/location'
import { supportsPushState } from './util/push-state'

import { HashHistory } from './history/hash'
import { HTML5History } from './history/html5'
import { AbstractHistory } from './history/abstract'

import type { Matcher } from './create-matcher'

export default class VueRouter {
  static install: () => void;
  static version: string;
  app: any;
  apps: Array<any>;
  ready: boolean;
  readyCbs: Array<Function>;
  options: RouterOptions;
  mode: string;
  history: HashHistory | HTML5History | AbstractHistory;
  matcher: Matcher;
  fallback: boolean;
  beforeHooks: Array<?NavigationGuard>;
  resolveHooks: Array<?NavigationGuard>;
  afterHooks: Array<?AfterNavigationHook>;

  constructor (options: RouterOptions = {}) {
    // æ ¹Vueå®ä¾‹
    this.app = null
    // å­˜å‚¨å«æœ‰this.$options.routerå±æ€§çš„Vueå®ä¾‹
    this.apps = []
    // ä¼ å…¥è·¯ç”±çš„é…ç½®
    this.options = options
    this.beforeHooks = []
    this.resolveHooks = []
    this.afterHooks = []
    // åˆ›å»ºè·¯ç”±åŒ¹é…å¯¹è±¡
    this.matcher = createMatcher(options.routes || [], this)
    // é»˜è®¤ä¸ºhashæ¨¡å¼
    let mode = options.mode || 'hash'
    // å½“æµè§ˆå™¨ä¸æ”¯æŒ history.pushState æ§åˆ¶è·¯ç”±æ˜¯å¦åº”è¯¥å›é€€åˆ° hash æ¨¡å¼ã€‚é»˜è®¤å€¼ä¸º true
    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false
    if (this.fallback) {
      mode = 'hash'
    }
    // æ”¯æŒæ‰€æœ‰ JavaScript è¿è¡Œç¯å¢ƒï¼Œå¦‚ Node.js æœåŠ¡å™¨ç«¯ã€‚å¦‚æœå‘ç°æ²¡æœ‰æµè§ˆå™¨çš„ APIï¼Œè·¯ç”±ä¼šè‡ªåŠ¨å¼ºåˆ¶è¿›å…¥è¿™ä¸ªæ¨¡å¼
    if (!inBrowser) {
      mode = 'abstract'
    }
    this.mode = mode
    // æ ¹æ®modeé‡‡ç”¨ä¸åŒçš„è·¯ç”±æ–¹å¼
    switch (mode) {
      case 'history':
        this.history = new HTML5History(this, options.base)
        break
      case 'hash':
        this.history = new HashHistory(this, options.base, this.fallback)
        break
      case 'abstract':
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== 'production') {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }

  get currentRoute (): ?Route {
    return this.history && this.history.current
  }

  init (app: any /* Vue component instance */) {
    // åœ¨åˆå§‹åŒ–Vue-Routerä¹‹å‰å¿…é¡»å…ˆé€šè¿‡Vue.use(VueRouter)æ³¨å†Œ
    process.env.NODE_ENV !== 'production' && assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )

    this.apps.push(app)

    // set up app destroyed handler
    // https://github.com/vuejs/vue-router/issues/2639
    app.$once('hook:destroyed', () => {
      // clean out app from this.apps array once destroyed
      const index = this.apps.indexOf(app)
      if (index > -1) this.apps.splice(index, 1)
      // ensure we still have a main app or null if no apps
      // we do not release the router so it can be reused
      if (this.app === app) this.app = this.apps[0] || null
    })

    // main app previously initialized
    // return as we don't need to set up new history listener
    if (this.app) {
      return
    }

    this.app = app

    const history = this.history

    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }

    history.listen(route => {
      this.apps.forEach((app) => {
        app._route = route
      })
    })
  }

  beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
  }

  beforeResolve (fn: Function): Function {
    return registerHook(this.resolveHooks, fn)
  }

  afterEach (fn: Function): Function {
    return registerHook(this.afterHooks, fn)
  }

  onReady (cb: Function, errorCb?: Function) {
    this.history.onReady(cb, errorCb)
  }

  onError (errorCb: Function) {
    this.history.onError(errorCb)
  }

  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }

  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }

  go (n: number) {
    this.history.go(n)
  }

  back () {
    this.go(-1)
  }

  forward () {
    this.go(1)
  }

  getMatchedComponents (to?: RawLocation | Route): Array<any> {
    const route: any = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(m => {
      return Object.keys(m.components).map(key => {
        return m.components[key]
      })
    }))
  }

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): {
    location: Location,
    route: Route,
    href: string,
    // for backwards compat
    normalizedTo: Location,
    resolved: Route
  } {
    current = current || this.history.current
    const location = normalizeLocation(
      to,
      current,
      append,
      this
    )
    const route = this.match(location, current)
    const fullPath = route.redirectedFrom || route.fullPath
    const base = this.history.base
    const href = createHref(base, fullPath, this.mode)
    return {
      location,
      route,
      href,
      // for backwards compat
      normalizedTo: location,
      resolved: route
    }
  }

  addRoutes (routes: Array<RouteConfig>) {
    this.matcher.addRoutes(routes)
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation())
    }
  }
}

function registerHook (list: Array<any>, fn: Function): Function {
  list.push(fn)
  return () => {
    const i = list.indexOf(fn)
    if (i > -1) list.splice(i, 1)
  }
}

function createHref (base: string, fullPath: string, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install
VueRouter.version = '__VERSION__'
// é€šè¿‡linkæ ‡ç­¾å¼•ç”¨jsçš„å®è¡Œè‡ªåŠ¨æ³¨å†Œ
if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter)
}

```
æ„é€ å‡½æ•°é‡Œé¢å®šä¹‰äº†ä¸€äº›å±æ€§ï¼Œå…¶ä¸­`this.app`è¡¨ç¤ºæ ¹`Vue`çš„å®ä¾‹ï¼Œ`this.apps`å­˜å‚¨å«æœ‰`this.$options.router`å±æ€§çš„Vueå®ä¾‹ï¼Œåˆå§‹åŒ–`Vue-Router`åä¼ å…¥çš„é…ç½®éƒ½ä¼šå­˜å‚¨åœ¨`this.options`ï¼Œ` this.beforeHooks`ã€`this.resolveHooks`ã€`this.afterHooks`ç”¨æ¥å­˜å‚¨é’©å­å‡½æ•°ï¼Œ`this.matcher`æ˜¯è·¯ç”±åŒ¹é…åè¿”å›çš„å¯¹è±¡ï¼Œ`this.fallback`ä¼šæ ¹æ®é…ç½®çš„`mode`å‚æ•°ä»¥åŠæµè§ˆå™¨æ”¯æŒåº¦æ¥å†³å®šç»™æ˜¯å¦å›é€€åˆ°`hash`æ¨¡å¼ï¼Œ`this.mode`å°±æ˜¯è·¯ç”±åˆ›å»ºçš„æ¨¡å¼ï¼Œè¿™é‡Œæä¾›`hash`ã€`history`ã€`abstract`ä¸‰ç§æ¨¡å¼ï¼Œ`this.history`è¡¨ç¤ºæ ¹æ®ä¸åŒçš„è·¯ç”±æ¨¡å¼æ¥åˆ›å»ºçš„è·¯ç”±`history`çš„å…·ä½“å®ç°æ–¹å¼ã€‚

å®ä¾‹åŒ–`Vue-Router`ä¹‹åä¼šè¿”å›å®ƒçš„å®ä¾‹`router`ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨`Vue-Router`çš„æ—¶å€™éœ€è¦åœ¨åˆå§‹åŒ–`Vue`çš„æ—¶å€™ä¼ å…¥è¿™ä¸ª`router`å±æ€§ï¼š

```javascript
new Vue({
  el: '#app',
  router,
  render: h => h(App)
})
```
è¿™ä¸ªæ—¶å€™ä¼šæŠŠ`router`å±æ€§é…ç½®åˆ°`this.$options`ï¼Œå›æƒ³åˆ°`install.js`é‡Œé¢åœ¨`beforeCreate`é’©å­å‡½æ•°é‡Œé¢æ‰§è¡Œçš„æ–¹æ³•ï¼š

```javascript
    beforeCreate () {
      // æ ¹ç»„ä»¶çš„$optionsä¸Šæ‰æœ‰routerå¯¹è±¡
      if (isDef(this.$options.router)) {
        // è®¾ç½®æ ¹è·¯ç”±
        this._routerRoot = this
        // è·å–åˆ°æ ¹ç»„ä»¶ä¸Šçš„routerå®ä¾‹
        this._router = this.$options.router
        // è·¯ç”±åˆå§‹åŒ–
        this._router.init(this)
        // ....
      }
```
æ‰€ä»¥è¿™ä¸ªæ—¶å€™ä¼šæ‰§è¡Œ`init`æ–¹æ³•ï¼š

```javascript

  init (app: any /* Vue component instance */) {
    // åœ¨åˆå§‹åŒ–Vue-Routerä¹‹å‰å¿…é¡»å…ˆé€šè¿‡Vue.use(VueRouter)æ³¨å†Œ
    process.env.NODE_ENV !== 'production' && assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )
    // å­˜å‚¨appå®ä¾‹
    this.apps.push(app)

    // set up app destroyed handler
    // https://github.com/vuejs/vue-router/issues/2639
    app.$once('hook:destroyed', () => {
      // clean out app from this.apps array once destroyed
      const index = this.apps.indexOf(app)
      if (index > -1) this.apps.splice(index, 1)
      // ensure we still have a main app or null if no apps
      // we do not release the router so it can be reused
      if (this.app === app) this.app = this.apps[0] || null
    })

    // main app previously initialized
    // return as we don't need to set up new history listener
    if (this.app) {
      return
    }

    this.app = app

    const history = this.history
    // æ ¹æ®historyå®ç°çš„æ–¹å¼ä¸åŒæ‰§è¡Œä¸åŒçš„é€»è¾‘
    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } else if (history instanceof HashHistory) {
      const setupHashListener = () => {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }
    // æ›´æ–°æ ¹ç»„ä»¶çš„è·¯ç”±å¯¹è±¡
    history.listen(route => {
      this.apps.forEach((app) => {
        app._route = route
      })
    })
  }
```
`init`å…¶å®æ²¡å¹²å¾ˆå¤šäº‹æƒ…ï¼Œé¦–å…ˆæŠŠä¼ å…¥çš„`Vue`å®ä¾‹å­˜å‚¨åˆ°`apps`æ•°ç»„ä¸­ï¼Œç„¶åæŠŠ`this.history`èµ‹å€¼ç»™ä¸€ä¸ªæœ¬åœ°å˜é‡ï¼Œæ ¹æ®`this.history`å®ç°æ–¹å¼çš„ä¸åŒæ‰§è¡Œä¸åŒçš„é€»è¾‘ï¼Œæœ€åé€šè¿‡`history`çš„å›è°ƒæ›´æ–°è·¯ç”±å¯¹è±¡ä¹Ÿå°±æ˜¯`this.$route`ã€‚

æ— è®º`this.history`æ˜¯åŸºäº`history`è¿˜æ˜¯`hash`å®ç°çš„ï¼Œæœ€åéƒ½ä¼šè°ƒç”¨`transitionTo`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å®šä¹‰åœ¨`src/history/base.js`ï¼š

```javascript
transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const route = this.router.match(location, this.current)
    this.confirmTransition(route, () => {
    // ...
  }
```
å®é™…ä¸Šå°±æ˜¯è°ƒç”¨`match`æ–¹æ³•ï¼š

```javascript

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }
```
é‚£æˆ‘ä»¬å¯ä»¥å…ˆæŠŠä¸Šé¢çš„é€»è¾‘æ”¾ä¸€è¾¹ï¼Œå…ˆäº†è§£ä¸€ä¸‹`matchers`çš„æ„å»ºï¼Œç›¸å…³çš„æºç åœ¨`src/create-matcher.js`:

##### matchçš„å®ç°
```javascript
/* @flow */

import type VueRouter from './index'
import { resolvePath } from './util/path'
import { assert, warn } from './util/warn'
import { createRoute } from './util/route'
import { fillParams } from './util/params'
import { createRouteMap } from './create-route-map'
import { normalizeLocation } from './util/location'

export type Matcher = {
  match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) => Route;
  addRoutes: (routes: Array<RouteConfig>) => void;
};

export function createMatcher (
  routes: Array<RouteConfig>,
  router: VueRouter
): Matcher {
  const { pathList, pathMap, nameMap } = createRouteMap(routes)
  // æ·»åŠ è·¯ç”±è·¯å¾„å…³ç³»æ˜ å°„
  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap)
  }

  function match (
    raw: RawLocation,
    currentRoute?: Route,
    redirectedFrom?: Location
  ): Route {
    // æ ¹æ®rawå’ŒcurrentRouteè®¡ç®—å‡ºæ–°çš„location
    const location = normalizeLocation(raw, currentRoute, false, router)
    const { name } = location

    if (name) {
      // å¦‚æœæ˜¯å‘½åè·¯ç”±ï¼Œå–å‡ºå¯¹åº”çš„è·¯ç”±record
      const record = nameMap[name]
      if (process.env.NODE_ENV !== 'production') {
        warn(record, `Route with name '${name}' does not exist`)
      }
      // ç”Ÿæˆä¸€æ¡æ–°è®°å½•
      if (!record) return _createRoute(null, location)
      const paramNames = record.regex.keys
        .filter(key => !key.optional)
        .map(key => key.name)

      if (typeof location.params !== 'object') {
        location.params = {}
      }
      // èµ‹å€¼params
      if (currentRoute && typeof currentRoute.params === 'object') {
        for (const key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key]
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, `named route "${name}"`)
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {}
      for (let i = 0; i < pathList.length; i++) {
        const path = pathList[i]
        const record = pathMap[path]
        if (matchRoute(record.regex, location.path, location.params)) {
          return _createRoute(record, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record: RouteRecord,
    location: Location
  ): Route {
    const originalRedirect = record.redirect
    let redirect = typeof originalRedirect === 'function'
      ? originalRedirect(createRoute(record, location, null, router))
      : originalRedirect

    if (typeof redirect === 'string') {
      redirect = { path: redirect }
    }

    if (!redirect || typeof redirect !== 'object') {
      if (process.env.NODE_ENV !== 'production') {
        warn(
          false, `invalid redirect option: ${JSON.stringify(redirect)}`
        )
      }
      return _createRoute(null, location)
    }

    const re: Object = redirect
    const { name, path } = re
    let { query, hash, params } = location
    query = re.hasOwnProperty('query') ? re.query : query
    hash = re.hasOwnProperty('hash') ? re.hash : hash
    params = re.hasOwnProperty('params') ? re.params : params

    if (name) {
      // resolved named direct
      const targetRecord = nameMap[name]
      if (process.env.NODE_ENV !== 'production') {
        assert(targetRecord, `redirect failed: named route "${name}" not found.`)
      }
      return match({
        _normalized: true,
        name,
        query,
        hash,
        params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      const rawPath = resolveRecordPath(path, record)
      // 2. resolve params
      const resolvedPath = fillParams(rawPath, params, `redirect route with path "${rawPath}"`)
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query,
        hash
      }, undefined, location)
    } else {
      if (process.env.NODE_ENV !== 'production') {
        warn(false, `invalid redirect option: ${JSON.stringify(redirect)}`)
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record: RouteRecord,
    location: Location,
    matchAs: string
  ): Route {
    const aliasedPath = fillParams(matchAs, location.params, `aliased route with path "${matchAs}"`)
    const aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    })
    if (aliasedMatch) {
      const matched = aliasedMatch.matched
      const aliasedRecord = matched[matched.length - 1]
      location.params = aliasedMatch.params
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record: ?RouteRecord,
    location: Location,
    redirectedFrom?: Location
  ): Route {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match,
    addRoutes
  }
}

function matchRoute (
  regex: RouteRegExp,
  path: string,
  params: Object
): boolean {
  const m = path.match(regex)

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (let i = 1, len = m.length; i < len; ++i) {
    const key = regex.keys[i - 1]
    const val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]
    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val
    }
  }

  return true
}

function resolveRecordPath (path: string, record: RouteRecord): string {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

```
`createMatcher`æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯åˆå§‹åŒ–è·¯ç”±çš„é…ç½®å¯¹è±¡`routes`ï¼Œç¬¬äºŒä¸ªæ˜¯æˆ‘ä»¬çš„è·¯ç”±å®ä¾‹`router`ï¼Œé¦–å…ˆä¼šè·‘ä¸€ä¸ª`createRouteMap`çš„é€»è¾‘ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªè·¯ç”±æ˜ å°„ï¼Œè¿™ä¸ªæ–¹æ³•å®šä¹‰åœ¨`src/create-route-map.js`ï¼š

```javascript
/* @flow */

import Regexp from 'path-to-regexp'
import { cleanPath } from './util/path'
import { assert, warn } from './util/warn'

export function createRouteMap (
  routes: Array<RouteConfig>,
  oldPathList?: Array<string>,
  oldPathMap?: Dictionary<RouteRecord>,
  oldNameMap?: Dictionary<RouteRecord>
): {
  pathList: Array<string>;
  pathMap: Dictionary<RouteRecord>;
  nameMap: Dictionary<RouteRecord>;
} {
  // the path list is used to control path matching priority
  const pathList: Array<string> = oldPathList || []
  // $flow-disable-line
  const pathMap: Dictionary<RouteRecord> = oldPathMap || Object.create(null)
  // $flow-disable-line
  const nameMap: Dictionary<RouteRecord> = oldNameMap || Object.create(null)

  routes.forEach(route => {
    addRouteRecord(pathList, pathMap, nameMap, route)
  })
  // ç¡®ä¿é€šé…ç¬¦çš„è·¯å¾„åœ¨æœ€åæ‰è¢«åŒ¹é…
  // ensure wildcard routes are always at the end
  for (let i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0])
      l--
      i--
    }
  }

  return {
    pathList,
    pathMap,
    nameMap
  }
}

function addRouteRecord (
  pathList: Array<string>,
  pathMap: Dictionary<RouteRecord>,
  nameMap: Dictionary<RouteRecord>,
  route: RouteConfig,
  parent?: RouteRecord,
  matchAs?: string
) {
  const { path, name } = route
  if (process.env.NODE_ENV !== 'production') {
    // pathä¸èƒ½ä¸ºç©ºå¹¶ä¸”componentçš„å€¼å¿…é¡»ç”¨ä¸€ä¸ªç»„ä»¶åè€Œä¸æ˜¯ä¸€ä¸ªstringå­—ç¬¦ä¸²
    assert(path != null, `"path" is required in a route configuration.`)
    assert(
      typeof route.component !== 'string',
      `route config "component" for path: ${String(path || name)} cannot be a ` +
      `string id. Use an actual component instead.`
    )
  }
  // pathToRegexpOptionsæ˜¯ç¼–è¯‘æ­£åˆ™çš„é€‰é¡¹
  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}
  // normalize path
  const normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  )
  // caseSensitiveåŒ¹é…è§„åˆ™æ˜¯å¦å¤§å°å†™æ•æ„Ÿï¼Ÿ(é»˜è®¤å€¼ï¼šfalse)
  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive
  }

  const record: RouteRecord = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name,
    parent,
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }
  // å¦‚æœæœ‰å­è·¯ç”±
  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(child => /^\/?$/.test(child.path))) {
        warn(
          false,
          `Named Route '${route.name}' has a default child route. ` +
          `When navigating to this named route (:to="{name: '${route.name}'"), ` +
          `the default child route will not be rendered. Remove the name from ` +
          `this route and use the name of the default child route for named ` +
          `links instead.`
        )
      }
    }
    // å¾ªç¯æ·»åŠ å­è·¯ç”±è·¯å¾„
    route.children.forEach(child => {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  }
  // è®¾ç½®äº†è·¯ç”±åˆ«å
  if (route.alias !== undefined) {
    // ç»Ÿä¸€è½¬æ¢ä¸ºæ•°ç»„
    const aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias]

    aliases.forEach(alias => {
      const aliasRoute = {
        path: alias,
        children: route.children
      }
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      )
    })
  }
  // æ·»åŠ pathè®°å½•ä»¥åŠå»ºç«‹pathå’Œè®°å½•çš„å¯¹åº”å…³ç³»
  if (!pathMap[record.path]) {
    pathList.push(record.path)
    pathMap[record.path] = record
  }
  // å¦‚æœé…ç½®äº†å‘½åè·¯ç”±ï¼Œç»™nameå’Œrecordå»ºç«‹æ˜ å°„å…³ç³»
  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      // å·²ç»æœ‰è¿™ä¸ªå‘½åçš„è·¯ç”±å­˜åœ¨å¹¶ä¸”æ²¡æœ‰ç»™è¿™ä¸ªè·¯ç”±è®¾ç½®é‡å®šå‘ï¼Œè¯´æ˜ç»™äº†é‡å¤å‘½å
      warn(
        false,
        `Duplicate named routes definition: ` +
        `{ name: "${name}", path: "${record.path}" }`
      )
    }
  }
}

function compileRouteRegex (path: string, pathToRegexpOptions: PathToRegexpOptions): RouteRegExp {
  const regex = Regexp(path, [], pathToRegexpOptions)
  if (process.env.NODE_ENV !== 'production') {
    const keys: any = Object.create(null)
    regex.keys.forEach(key => {
      // æœ‰é‡å¤çš„åŠ¨æ€è·¯å¾„å‚æ•°
      warn(!keys[key.name], `Duplicate param keys in route with path: "${path}"`)
      keys[key.name] = true
    })
  }
  return regex
}

function normalizePath (path: string, parent?: RouteRecord, strict?: boolean): string {
  // æ›¿æ¢æ ¹è·¯ç”±è·¯å¾„
  if (!strict) path = path.replace(/\/$/, '')
  if (path[0] === '/') return path
  if (parent == null) return path
  // å°†//çš„è·¯å¾„æ›¿æ¢æˆ/
  return cleanPath(`${parent.path}/${path}`)
}

```
è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯å°†è·¯ç”±é…ç½®è½¬æ¢æˆä¸€ç»„ç»„æ˜ å°„å…³ç³»è¡¨ï¼Œè¿”å›ä¸€ä¸ªå¯¹è±¡:

```javascript
  return {
    pathList,
    pathMap,
    nameMap
  }
```
å…¶ä¸­`pathList`å­˜å‚¨äº†æ‰€æœ‰çš„`path`ï¼Œ`pathMap`è¡¨ç¤ºäº†`path`åˆ°`RouteRecord`å¯¹è±¡çš„ä¸€ä¸€æ˜ å°„å…³ç³»ï¼Œ`nameMap`åˆ™è¡¨ç¤ºäº†`name`åˆ°`RouteRecord`å¯¹è±¡çš„æ˜ å°„å…³ç³»ï¼Œ`RouteRecord`å¯¹è±¡æ˜¯å¯¹è·¯ç”±é…ç½®å‚æ•°`routes`æ¯ä¸€é¡¹è¿›è¡Œéå†åè°ƒç”¨`addRouteRecord`æ–¹æ³•ç”Ÿæˆçš„ä¸€æ¡è®°å½•ï¼Œæ–¹æ³•å®šä¹‰å¦‚ä¸‹ï¼š

```javascript
function addRouteRecord (
  pathList: Array<string>,
  pathMap: Dictionary<RouteRecord>,
  nameMap: Dictionary<RouteRecord>,
  route: RouteConfig,
  parent?: RouteRecord,
  matchAs?: string
) {
  const { path, name } = route
  if (process.env.NODE_ENV !== 'production') {
    // pathä¸èƒ½ä¸ºç©ºå¹¶ä¸”componentçš„å€¼å¿…é¡»ç”¨ä¸€ä¸ªç»„ä»¶åè€Œä¸æ˜¯ä¸€ä¸ªstringå­—ç¬¦ä¸²
    assert(path != null, `"path" is required in a route configuration.`)
    assert(
      typeof route.component !== 'string',
      `route config "component" for path: ${String(path || name)} cannot be a ` +
      `string id. Use an actual component instead.`
    )
  }
  // pathToRegexpOptionsæ˜¯ç¼–è¯‘æ­£åˆ™çš„é€‰é¡¹
  const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}
  // normalize path
  const normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  )
  // caseSensitiveåŒ¹é…è§„åˆ™æ˜¯å¦å¤§å°å†™æ•æ„Ÿï¼Ÿ(é»˜è®¤å€¼ï¼šfalse)
  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive
  }

  const record: RouteRecord = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name,
    parent,
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }
  // å¦‚æœæœ‰å­è·¯ç”±
  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== 'production') {
      if (route.name && !route.redirect && route.children.some(child => /^\/?$/.test(child.path))) {
        warn(
          false,
          `Named Route '${route.name}' has a default child route. ` +
          `When navigating to this named route (:to="{name: '${route.name}'"), ` +
          `the default child route will not be rendered. Remove the name from ` +
          `this route and use the name of the default child route for named ` +
          `links instead.`
        )
      }
    }
    // å¾ªç¯æ·»åŠ å­è·¯ç”±è·¯å¾„
    route.children.forEach(child => {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  }
  // è®¾ç½®äº†è·¯ç”±åˆ«å
  if (route.alias !== undefined) {
    // ç»Ÿä¸€è½¬æ¢ä¸ºæ•°ç»„
    const aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias]

    aliases.forEach(alias => {
      const aliasRoute = {
        path: alias,
        children: route.children
      }
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      )
    })
  }
  // æ·»åŠ pathè®°å½•ä»¥åŠå»ºç«‹pathå’Œè®°å½•çš„å¯¹åº”å…³ç³»
  if (!pathMap[record.path]) {
    pathList.push(record.path)
    pathMap[record.path] = record
  }
  // å¦‚æœé…ç½®äº†å‘½åè·¯ç”±ï¼Œç»™nameå’Œrecordå»ºç«‹æ˜ å°„å…³ç³»
  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      // å·²ç»æœ‰è¿™ä¸ªå‘½åçš„è·¯ç”±å­˜åœ¨å¹¶ä¸”æ²¡æœ‰ç»™è¿™ä¸ªè·¯ç”±è®¾ç½®é‡å®šå‘ï¼Œè¯´æ˜ç»™äº†é‡å¤å‘½å
      warn(
        false,
        `Duplicate named routes definition: ` +
        `{ name: "${name}", path: "${record.path}" }`
      )
    }
  }
}
```
è¿™ä¸ªæ–¹æ³•é¦–å…ˆä¼šå¯¹`path`ä½¿ç”¨`normalizePath`è¿›è¡Œè§„èŒƒåŒ–å¤„ç†ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ï¼š

```javascript
function normalizePath (path: string, parent?: RouteRecord, strict?: boolean): string {
  // æ›¿æ¢æ ¹è·¯ç”±è·¯å¾„
  if (!strict) path = path.replace(/\/$/, '')
  // è¯´æ˜æ˜¯ä¸€çº§è·¯å¾„ï¼Œç›´æ¥è¿”å›
  if (path[0] === '/') return path
  if (parent == null) return path
  //  å°†//çš„è·¯å¾„æ›¿æ¢æˆ/å¹¶ä¸”æ‹¼æ¥çˆ¶è·¯ç”±çš„è·¯å¾„
  return cleanPath(`${parent.path}/${path}`)
}
```
ä¸»è¦ä½œç”¨å°±æ˜¯ç”Ÿæˆå¤šå±‚è·¯ç”±çš„å…·ä½“è·¯å¾„ï¼Œç„¶åæ ¹æ®å·²æœ‰å‚æ•°æ„å»º`RouteRecord`ï¼š

```
  const record: RouteRecord = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name,
    parent,
    matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }
```
è¿™é‡Œè§£é‡Šä¸‹`regex`è¿™ä¸ªå‚æ•°ï¼Œç”¨åˆ°äº†`path-to-regexp`è¿™ä¸ªåº“ï¼Œè¿™ä¸ªåº“å¯ä»¥æŠŠè·¯å¾„è½¬æ¢ä¸ºæ­£åˆ™è¡¨è¾¾å¼ï¼Œä¸¾ä¸ªæ —å­ï¼š

```javascript
const keys = []
const regexp = pathToRegexp('/foo/:bar', keys)
// regexp = /^\/foo\/([^\/]+?)\/?$/i
// keys = [{ name: 'bar', prefix: '/', delimiter: '/', optional: false, repeat: false, pattern: '[^\\/]+?' }]

```
ç”¨è¿™ä¸ªåº“ä½œä¸ºè·¯å¾„åŒ¹é…å¼•æ“æ˜¯ä¸ºäº†å®ç°å¯é€‰çš„åŠ¨æ€è·¯å¾„å‚æ•°ã€åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªã€ä¸€ä¸ªæˆ–å¤šä¸ªï¼Œç”šè‡³æ˜¯è‡ªå®šä¹‰æ­£åˆ™åŒ¹é…ã€‚
ç´§æ¥ç€åˆ¤æ–­æ˜¯å¦é…ç½®äº†å­è·¯ç”±ï¼Œç„¶åå¾ªç¯è°ƒç”¨`addRouteRecord`è¿™ä¸ªæ–¹æ³•ï¼Œå¹¶æŠŠå½“å‰çš„`record`ä½œä¸º`parent`ï¼Œå¦‚æœè®¾ç½®äº†è·¯ç”±åˆ«åï¼Œä¹Ÿä¼šç»™åˆ«åæ·»åŠ ä¸€ä»½`record`ï¼Œæœ€åå°±æ˜¯æ›´æ–°æ˜ å°„è¡¨ï¼Œè¿”å›ä¸€ä¸ª`Array`å¯¹è±¡ä»¥åŠä¸¤ä¸ª`Dictionary`å¯¹è±¡ã€‚

å›åˆ°`create-matcher.js`ï¼Œå®ƒå¯¹å¤–æš´éœ²äº†ä¸¤ä¸ªæ–¹æ³•ï¼š`addRoutes`å’Œ`match`ï¼Œåˆ†åˆ«ç”¨äºåŠ¨æ€æ·»åŠ è·¯ç”±é…ç½®ä»¥åŠè¿”å›ä¸€ä¸ªè·¯ç”±çš„è·¯å¾„ï¼Œå…ˆçœ‹`addRoutes`ï¼š

```javascripts
function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap)
  }
```
å…¶å®å°±æ˜¯åœ¨ç°æœ‰çš„`pathList`ã€`pathMap`ã€`nameMap`ä¸ŠåŠ¨æ€æ·»åŠ ä¸€æ¡æ–°çºªå½•ï¼Œè¿™å‡ ä¸ªéƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œæ‰§è¡Œ`addRoutes`ä¹‹åéƒ½ä¼šè¢«ä¿®æ”¹ã€‚

`match`å‡½æ•°ç›¸å¯¹å¤æ‚ä¸€ç‚¹ï¼Œæ¥å—ä¸‰ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥ä¸º`string`ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ª`Location`å¯¹è±¡ï¼Œç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºå½“å‰çš„è·¯ç”±è·¯å¾„ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¹Ÿæ˜¯`Location`å¯¹è±¡ï¼Œè·Ÿé‡å®šå‘æœ‰å…³ï¼š

```javascript

  function match (
    raw: RawLocation,
    currentRoute?: Route,
    redirectedFrom?: Location
  ): Route {
    // æ ¹æ®rawå’ŒcurrentRouteè®¡ç®—å‡ºæ–°çš„location
    const location = normalizeLocation(raw, currentRoute, false, router)
    const { name } = location

    if (name) {
      // å¦‚æœæ˜¯å‘½åè·¯ç”±ï¼Œå–å‡ºå¯¹åº”çš„è·¯ç”±record
      const record = nameMap[name]
      if (process.env.NODE_ENV !== 'production') {
        warn(record, `Route with name '${name}' does not exist`)
      }
      // ç”Ÿæˆä¸€æ¡æ–°è®°å½•
      if (!record) return _createRoute(null, location)
      const paramNames = record.regex.keys
        .filter(key => !key.optional)
        .map(key => key.name)

      if (typeof location.params !== 'object') {
        location.params = {}
      }
      // èµ‹å€¼params
      if (currentRoute && typeof currentRoute.params === 'object') {
        for (const key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key]
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, `named route "${name}"`)
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {}
      for (let i = 0; i < pathList.length; i++) {
        const path = pathList[i]
        const record = pathMap[path]
        if (matchRoute(record.regex, location.path, location.params)) {
          return _createRoute(record, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }
```
ä¸€å¼€å§‹ä¼šæ‰§è¡Œ`normalizeLocation`æ–¹æ³•ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„`location`ï¼Œçœ‹ä¸€çœ¼`normalizeLocation`çš„å®ç°ï¼š

```javascript
export function normalizeLocation (
  raw: RawLocation,
  current: ?Route,
  append: ?boolean,
  router: ?VueRouter
): Location {
  let next: Location = typeof raw === 'string' ? { path: raw } : raw
  // named target
  if (next._normalized) {
    // å·²ç»normalizedçš„ç›´æ¥è¿”å›
    return next
  } else if (next.name) {
    // å¦‚æœæ˜¯å‘½åè·¯ç”±ï¼Œè¿”å›ä¸€ä»½å¤‡ä»½
    return extend({}, raw)
  }

  // relative params
  // æ²¡æœ‰pathï¼Œä½†æ˜¯æœ‰paramså’Œcurrent
  if (!next.path && next.params && current) {
    next = extend({}, next)
    next._normalized = true
    // æ‹¿åˆ°params
    const params: any = extend(extend({}, current.params), next.params)
    if (current.name) {
      next.name = current.name
      next.params = params
    } else if (current.matched.length) {
      const rawPath = current.matched[current.matched.length - 1].path
      // æ ¹æ®rawPathå’Œparamsè®¡ç®—å‡ºå½“å‰path
      next.path = fillParams(rawPath, params, `path ${current.path}`)
    } else if (process.env.NODE_ENV !== 'production') {
      warn(false, `relative params navigation requires a current route.`)
    }
    return next
  }
  // å°†pathæ‹†åˆ†æˆpathã€hashå’Œquery
  const parsedPath = parsePath(next.path || '')
  const basePath = (current && current.path) || '/'
  // è¿”å›æœ€åæ‹¼æ¥å®Œæˆå¥½çš„è·¯å¾„ï¼Œappendç”¨äºåˆ¤æ–­æ˜¯å¦åœ¨å½“å‰ (ç›¸å¯¹) è·¯å¾„å‰æ·»åŠ åŸºè·¯å¾„
  const path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath
  // è§£æquery parseQueryæ˜¯æä¾›è‡ªå®šä¹‰æŸ¥è¯¢å­—ç¬¦ä¸²çš„è§£æ/åè§£æå‡½æ•°ï¼Œç”¨äºè¦†ç›–é»˜è®¤è¡Œä¸º
  const query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  )
  // è·¯ç”±çš„hashå€¼
  let hash = next.hash || parsedPath.hash
  if (hash && hash.charAt(0) !== '#') {
    hash = `#${hash}`
  }

  return {
    _normalized: true,
    path,
    query,
    hash
  }
}

```
è¿™ä¸ªæ–¹æ³•é¦–å…ˆä¼šåˆ¤æ–­å½“å‰çš„`RawLocation`æ˜¯å¦å·²ç»ç»è¿‡`_normalized`å¤„ç†ï¼Œæ˜¯çš„è¯ç›´æ¥è¿”å›ï¼Œå¦åˆ™çš„è¯ç»§ç»­åˆ¤æ–­å½“å‰`Location`æ˜¯å¦æœ‰`name`å­—æ®µï¼Œæœ‰çš„è¯é€šè¿‡`extend`æ–¹æ³•æ‹·è´ä¸€ä»½`raw`å¯¹è±¡ç›´æ¥è¿”å›ï¼Œè¿™ä¸ª`extend`æ–¹æ³•çš„å®ç°å¾ˆç®€å•ï¼š

```javascript
export function extend (a, b) {
  for (const key in b) {
    a[key] = b[key]
  }
  return a
}
```
å½“ä¸Šé¢çš„æƒ…å†µéƒ½ä¸æ»¡è¶³ï¼Œæ¥ç€è¿›å…¥ä¸‹ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶ï¼Œå¦‚æœæœ‰å½“å‰`Route`ä¿¡æ¯ï¼Œæœ‰`params`ä½†æ˜¯æ²¡æœ‰`path`çš„æƒ…å†µï¼Œé¦–å…ˆä¼šè®¾ç½®`_normalized`æ ‡å¿—ä½ï¼Œç„¶åå¯¹`params`å‚æ•°è¿›è¡Œåˆå¹¶å¤„ç†ï¼Œç„¶åç»§ç»­åˆ†ä¸ºä¸¤ç§æƒ…å†µå¤„ç†ï¼Œåˆ†åˆ«æ˜¯`current`æœ‰`name`ä¸å¦ï¼Œå‰è€…çš„è¯ä¼šç›´æ¥å°†`current`çš„`name`å’Œæ‹¼æ¥åçš„`params`èµ‹å€¼ç»™`next`åç›´æ¥è¿”å›ï¼Œåè€…çš„è¯ä¼šä»è·¯ç”±è®°å½•é‡Œé¢æ‰¾åˆ°æœ€æ–°çš„ä¸€æ¡è®°å½•çš„`path`ï¼Œè°ƒç”¨`fillParams`æ–¹æ³•æ ¹æ®`rawPath`å’Œ`params`è®¡ç®—å½“å‰`path`ï¼Œçœ‹ä¸€ä¸‹`fillParams`å¯¹ç›¸å¯¹è·¯å¾„çš„å¤„ç†ï¼š

```javascript
/* @flow */

import { warn } from './warn'
import Regexp from 'path-to-regexp'

// $flow-disable-line
const regexpCompileCache: {
  [key: string]: Function
} = Object.create(null)

export function fillParams (
  path: string,
  params: ?Object,
  routeMsg: string
): string {
  params = params || {}
  try {
    const filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = Regexp.compile(path))
    // å¦‚æœparamä¸­æœ‰åä¸ºpathMatchçš„keyå°†ä»–è®¾ç½®ä¸º{0, params[patchMatch]}çš„é”®å€¼å¯¹
    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
    if (params.pathMatch) params[0] = params.pathMatch
    // å°†åŠ¨æ€è·¯å¾„å‚æ•°æ›¿æ¢æˆæ­£å¼å‚æ•°
    return filler(params, { pretty: true })
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      warn(false, `missing param for ${routeMsg}: ${e.message}`)
    }
    return ''
  } finally {
    // delete the 0 if it was added
    delete params[0]
  }
}

```
å…¶å®è¿™é‡Œå°±æ˜¯æŠŠå½¢å¦‚`{zapId: 1}`çš„paramså‚æ•°é€šè¿‡`Regexp.compile`ç”Ÿæˆçš„æ–¹æ³•æ‹¼æ¥åˆ°`path`åé¢ï¼Œå°±åƒè¿™æ ·ï¼š

```javascript
const toPath = pathToRegexp.compile('/user/:id')

toPath({ id: 123 }) //=> "/user/123"
```
å›åˆ°`create-matcher.js`ï¼Œè®¡ç®—å‡ºæ–°çš„`location`ä¹‹åå¯¹å‘½åè·¯ç”±å’Œéå‘½åè·¯ç”±è¿›è¡Œäº†ä¸åŒçš„å¤„ç†ï¼Œå¦‚æœ`name`å­˜åœ¨ï¼Œä»`nameMap`å­—å…¸é‡Œé¢åŒ¹é…å‡ºå¯¹åº”çš„`record`ï¼Œå¦‚æœ`record`ä¸å­˜åœ¨é€šè¿‡`_createRoute`ç”Ÿæˆä¸€æ¡æ–°çš„`record`ç›´æ¥è¿”å›ï¼Œå¦åˆ™å–å‡ºè¿™æ¡`record`é‡Œé¢çš„`params`çš„`key`ç»„æˆçš„æ•°ç»„ï¼Œå°†`currentRoute`é‡Œé¢çš„`params`ä»¥`key`/`value`çš„å½¢å¼ä¸é‡å¤åœ°å­˜å…¥åä¸º`location.params`çš„ä¸€ä¸ªå¯¹è±¡é‡Œé¢ï¼Œæœ€åä¾ç„¶æ˜¯é€šè¿‡`fillParams`æ‹¼æ¥`params`å‚æ•°åˆ°è·¯å¾„å°¾éƒ¨ï¼Œé€šè¿‡`_createRoute`æ–¹æ³•åˆ›å»ºä¸€æ¡æ–°è·¯å¾„è¿”å›ã€‚

åä¹‹ï¼Œå¦‚æœæ˜¯éå‘½åè·¯ç”±ï¼Œä¼šé€šè¿‡`pathList`è¿”å›`path`å¯¹åº”çš„`record`ï¼Œç„¶åé€šè¿‡`createRoute`æ–¹æ³•åˆ¤æ–­æ˜¯å¦èƒ½å¤ŸåŒ¹é…åˆ°è·¯ç”±ä¿¡æ¯ï¼Œæ˜¯çš„è¯ä¹Ÿä¼šé€šè¿‡`_createRoute`ç”Ÿæˆä¸€æ¡æ–°è·¯å¾„è¿”å›ã€‚æ¥ä¸‹æ¥åªè¦ææ‡‚`matchRoute`å’Œ`_createRoute`å¹²äº†ä»€ä¹ˆå°±è¡Œäº†ï¼Œå…ˆçœ‹`matchRoute`ï¼š

```javascript
function matchRoute (
  regex: RouteRegExp,
  path: string,
  params: Object
): boolean {
  const m = path.match(regex)

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (let i = 1, len = m.length; i < len; ++i) {
    const key = regex.keys[i - 1]
    const val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i]
    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = val
    }
  }

  return true
}
```
å…¶å®å°±æ˜¯é€šè¿‡`match`æ–¹æ³•åšåˆ¤æ–­ï¼Œå¦‚æœæ²¡åŒ¹é…åˆ°ç›´æ¥è¿”å›`false`ï¼Œå¦‚æœä¼ å…¥äº†`params`ä¼šå°†`path`é‡Œé¢çš„`params`ä»¥`key`/`value`å½¢å¼å­˜å…¥ï¼Œè¿™ä¸ªä¼ å…¥çš„`params`åœ¨è¿™é‡Œæ˜¯`location.params`æ‰€ä»¥å’Œå‰é¢åšçš„æ˜¯ä¸€æ ·çš„æ“ä½œã€‚

æ¥ç€çœ‹`_createRoute`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¹Ÿåœ¨`create_matcher.js`å†…éƒ¨ï¼š

```javascript

  function _createRoute (
    record: ?RouteRecord,
    location: Location,
    redirectedFrom?: Location
  ): Route {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }
```
æ— è®ºæ˜¯å¦è®¾ç½®äº†`redirect`è¿˜æ˜¯`alias`æœ€åéƒ½ä¼šé‡æ–°è°ƒç”¨`_createRoute`ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥çœ‹æœ€åçš„`createRoute`æ–¹æ³•ï¼š

```javascript
/* @flow */

import type VueRouter from '../index'
import { stringifyQuery } from './query'

const trailingSlashRE = /\/?$/

export function createRoute (
  record: ?RouteRecord,
  location: Location,
  redirectedFrom?: ?Location,
  router?: VueRouter
): Route {
  // æä¾›è‡ªå®šä¹‰æŸ¥è¯¢å­—ç¬¦ä¸²çš„è§£æ/åè§£æå‡½æ•°ã€‚è¦†ç›–é»˜è®¤è¡Œä¸º
  const stringifyQuery = router && router.options.stringifyQuery

  let query: any = location.query || {}
  try {
    query = clone(query)
  } catch (e) {}

  const route: Route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery), // å®Œæ•´è·¯å¾„
    matched: record ? formatMatch(record) : []
  }
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery)
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    const res = {}
    for (const key in value) {
      res[key] = clone(value[key])
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
export const START = createRoute(null, {
  path: '/'
})

function formatMatch (record: ?RouteRecord): Array<RouteRecord> {
  const res = []
  while (record) {
    res.unshift(record)
    record = record.parent
  }
  return res
}

function getFullPath (
  { path, query = {}, hash = '' },
  _stringifyQuery
): string {
  const stringify = _stringifyQuery || stringifyQuery
  return (path || '/') + stringify(query) + hash
}

export function isSameRoute (a: Route, b: ?Route): boolean {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a = {}, b = {}): boolean {
  // handle null value #1566
  if (!a || !b) return a === b
  const aKeys = Object.keys(a)
  const bKeys = Object.keys(b)
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(key => {
    const aVal = a[key]
    const bVal = b[key]
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

export function isIncludedRoute (current: Route, target: Route): boolean {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current: Dictionary<string>, target: Dictionary<string>): boolean {
  for (const key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

```
é€šè¿‡ä¼ å…¥çš„`record`å’Œ`location`åˆ›å»ºä¸€ä¸ªä¸å¯è¢«ä¿®æ”¹çš„`Route`å¯¹è±¡ï¼Œå…¶ä¸­æœ‰ä¸ª`matched`å±æ€§é€šè¿‡`formatMatch`æ–¹æ³•æ„å»ºï¼š

```javascript
function formatMatch (record: ?RouteRecord): Array<RouteRecord> {
  const res = []
  while (record) {
    res.unshift(record)
    record = record.parent
  }
  return res
}
```
é€šè¿‡å¾ªç¯ä¸æ–­åœ°æŸ¥æ‰¾å½“å‰`record`çš„`parent`ï¼Œç„¶åè¿”å›è¿™æ¡çº¿ä¸Šæ‰€æœ‰çš„`record`ç»„æˆçš„æ•°ç»„ã€‚

##### è·¯ç”±çš„è·³è½¬
æ— è®ºæ˜¯`Hash`è·¯ç”±è¿˜æ˜¯`History`è·¯ç”±ï¼Œåœ¨åˆå§‹åŒ–çš„æ—¶å€™éƒ½ä¼šé€šè¿‡`transitionTo`æ–¹æ³•è·³è½¬åˆ°åˆå§‹è·¯å¾„ï¼Œè¿™ä¸ªæ–¹æ³•ä¹Ÿæ˜¯æˆ‘ä»¬åˆ‡æ¢è·¯ç”±è·¯å¾„æ—¶å€™ä½¿ç”¨çš„æ–¹æ³•ï¼Œä¸‹é¢åˆ†æä¸€ä¸‹è¯¥æ–¹æ³•çš„å®ç°è¿‡ç¨‹ï¼š

```javascript
 transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    // é€šè¿‡locationå’Œcurrentè¿”å›åˆå§‹åŒ–Routeä¿¡æ¯
    const route = this.router.match(location, this.current)
    this.confirmTransition(route, () => {
      this.updateRoute(route)
      // æ‰§è¡ŒonCompleteå›è°ƒ
      onComplete && onComplete(route)
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb => { cb(route) })
      }
    }, err => {
      // å¦‚æœè·³è½¬è¢«ç»ˆæ­¢
      if (onAbort) {
        onAbort(err)
      }
      if (err && !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb => { cb(err) })
      }
    })
  }
```
åˆå§‹åŒ–è°ƒç”¨çš„æ—¶å€™ï¼Œæ‹¿åˆ°çš„æ˜¯åˆå§‹åŒ–çš„`Route`ï¼Œé€šè¿‡`confirmTransition`æ–¹æ³•è¿›è¡Œå®é™…çš„è·³è½¬æ“ä½œï¼ŒåŒæ—¶å¯¹è·³è½¬æˆåŠŸå’Œå¤±è´¥ä¸¤ç§æƒ…å†µéƒ½è®¾ç½®äº†å›è°ƒå‡½æ•°ï¼Œçœ‹ä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„å®šä¹‰ï¼š

```javascript

  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {
    const current = this.current
    const abort = err => {
      if (isError(err)) {
        // å°†æ‰€æœ‰çš„é”™è¯¯ä¿¡æ¯éƒ½å­˜å…¥errorCbs
        if (this.errorCbs.length) {
          this.errorCbs.forEach(cb => { cb(err) })
        } else {
          warn(false, 'uncaught error during route navigation:')
          console.error(err)
        }
      }
      onAbort && onAbort(err)
    }
    if (
      // å¦‚æœæ˜¯åŒä¸€ä¸ªè·¯ç”±è·¯å¾„
      isSameRoute(route, current) &&
      // in the case the route map has been dynamically appended to
      route.matched.length === current.matched.length
    ) {
      // ensureURLåœ¨ä¸åŒçš„è·¯ç”±å®ç°æ–¹å¼é‡Œé¢è¯¥æ–¹æ³•çš„å®ç°ä¸ä¸€æ ·
      this.ensureURL()
      // å¦‚æœè®¾ç½®äº†abortæ–¹æ³•è¿™é‡Œç›´æ¥è°ƒç”¨
      return abort()
    }
    // æ‹¿åˆ°è·¯å¾„çš„å˜åŒ–éƒ¨åˆ†ä»¥åŠé—å¼ƒéƒ¨åˆ†å’Œå‡çº§éƒ¨åˆ†
    const {
      updated,
      deactivated,
      activated
    } = resolveQueue(this.current.matched, route.matched)
    // ç»´æŒä¸€ä¸ªå¯¹åº”è·¯å¾„å˜åŒ–çš„å¯¼èˆªå®ˆå«çš„é’©å­ç»„æˆçš„List
    const queue: Array<?NavigationGuard> = [].concat(
      // in-component leave guards
      extractLeaveGuards(deactivated),
      // global before hooks
      this.router.beforeHooks,
      // in-component update hooks
      extractUpdateHooks(updated),
      // in-config enter guards
      activated.map(m => m.beforeEnter),
      // async components
      resolveAsyncComponents(activated)
    )

    this.pending = route
    // å®šä¹‰ä¸€ä¸ªè¿­ä»£å™¨
    const iterator = (hook: NavigationGuard, next) => {
      if (this.pending !== route) {
        return abort()
      }
      try {
        hook(route, current, (to: any) => {
          if (to === false || isError(to)) {
            // next(false) -> abort navigation, ensure current URL
            this.ensureURL(true)
            abort(to)
          } else if (
            typeof to === 'string' ||
            (typeof to === 'object' && (
              typeof to.path === 'string' ||
              typeof to.name === 'string'
            ))
          ) {
            // next('/') or next({ path: '/' }) -> redirect
            abort()
            if (typeof to === 'object' && to.replace) {
              this.replace(to)
            } else {
              this.push(to)
            }
          } else {
            // ç¡®è®¤è·³è½¬ï¼Œæ‰§è¡Œå›è°ƒ
            // confirm transition and pass on the value
            next(to)
          }
        })
      } catch (e) {
        abort(e)
      }
    }

    runQueue(queue, iterator, () => {
      const postEnterCbs = []
      const isValid = () => this.current === route
      // wait until async components are resolved before
      // extracting in-component enter guards
      // æ‰§è¡ŒbeforeRouteEnteré’©å­å‡½æ•°
      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)
      const queue = enterGuards.concat(this.router.resolveHooks)
      runQueue(queue, iterator, () => {
        if (this.pending !== route) {
          return abort()
        }
        this.pending = null
        onComplete(route)
        if (this.router.app) {
          this.router.app.$nextTick(() => {
            postEnterCbs.forEach(cb => { cb() })
          })
        }
      })
    })
  }
```
é¦–å…ˆå®šä¹‰äº†ä¸€ä¸ª`abort`å‡½æ•°ç”¨äºå¤„ç†è·¯ç”±è·³è½¬å¤±è´¥çš„æƒ…å†µä»¥åŠæ‰§è¡Œ`onAbort`å›è°ƒï¼Œç„¶ååˆ¤æ–­å¦‚æœè¦è·³è½¬çš„è·¯ç”±å’Œå½“å‰è·¯ç”±æ˜¯åŒä¸€ä¸ªçš„è¯ï¼Œç›´æ¥è°ƒç”¨`this.ensureURL()`å’Œ`abort()`ï¼Œè¿™ä¸ª`ensureURL`åœ¨ä¸åŒçš„è·¯ç”±å®ç°æ–¹å¼é‡Œé¢è¯¥æ–¹æ³•çš„å®ç°ä¸ä¸€æ ·ï¼Œæœ€ç»ˆéƒ½æ˜¯åšäº†è·¯ç”±è·³è½¬çš„æ“ä½œï¼Œç´§æ¥ç€é€šè¿‡`resolveQueue`æ–¹æ³•æ‹¿åˆ°ä¸‰ä¸ªæ•°ç»„ï¼Œåˆ†åˆ«å­˜å‚¨ç€å›ºå®šçš„éƒ¨åˆ†ï¼Œé—å¼ƒçš„éƒ¨åˆ†ä»¥åŠæ›´æ–°çš„éƒ¨åˆ†ï¼Œè¿™ä¸ªæ–¹æ³•çš„å®ç°å¦‚ä¸‹ï¼š

```javascript
function resolveQueue (
  current: Array<RouteRecord>,
  next: Array<RouteRecord>
): {
  updated: Array<RouteRecord>,
  activated: Array<RouteRecord>,
  deactivated: Array<RouteRecord>
} {
  let i
  const max = Math.max(current.length, next.length)
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}
```
è·¯ç”±ä»`current`å˜ä¸º`next`ï¼Œä¸¤ä¸ªè·¯å¾„çš„å…¬å…±éƒ¨åˆ†å°±æ˜¯`next.slice(0, i)`ï¼Œ`next.slice(0, i)`å°±æ˜¯è·¯å¾„éœ€è¦æ›´æ–°çš„éƒ¨åˆ†ï¼Œè€Œ`current.slice(i)`å°±æ˜¯è·¯å¾„éœ€è¦å˜åŒ–çš„éƒ¨åˆ†ã€‚

æ‹¿åˆ°ä¸‰ä¸ªæ•°ç»„ä¹‹åä¼šæ„é€ ä¸€ä¸ª`queue`é˜Ÿåˆ—ï¼Œé‡Œé¢å­˜å‚¨äº†è·¯å¾„å˜åŒ–è¦æ‰§è¡Œçš„é’©å­å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯å®˜æ–¹è¯´çš„è·¯ç”±å®ˆå«ï¼Œä¼šæŒ‰æ¬¡åºæ‰§è¡Œä¸€äº›è¯¸å¦‚`beforeRouteLeave`ã€`beforeRouteUpdate `ç­‰æ–¹æ³•ï¼Œä¸‹é¢è¿˜ä¼šå®šä¹‰ä¸€ä¸ªè¿­ä»£å™¨ï¼Œè¿™ä¸ªè¿­ä»£å™¨ä¼šæ ¹æ®ä¼ å…¥çš„`ro`å‚æ•°æ¥å†³å®šæ‰§è¡Œ`abort`è¿˜æ˜¯`next`æ–¹æ³•ï¼Œæœ€åæ‰§è¡Œ`runQueue`æ–¹æ³•æ¥æ‰§è¡Œè¿™ä¸ªé˜Ÿåˆ—ï¼Œè¿™ä¸ªæ–¹æ³•çš„å®šä¹‰å¦‚ä¸‹ï¼š

```javascript
export function runQueue (queue: Array<?NavigationGuard>, fn: Function, cb: Function) {
  const step = index => {
    if (index >= queue.length) {
      cb()
    } else {
      if (queue[index]) {
        fn(queue[index], () => {
          step(index + 1)
        })
      } else {
        step(index + 1)
      }
    }
  }
  step(0)
}
```
è¿™é‡Œçš„`fn`å…¶å®å°±æ˜¯`iterator`é‡Œé¢çš„`next`å‡½æ•°ï¼Œåªæœ‰æ‰§è¡Œäº†`next`å‡½æ•°`index`æ‰ä¼š`+1`ï¼Œæ‰ä¼šè¿›è¡Œç®¡é“ä¸­çš„ä¸‹ä¸€ä¸ªé’©å­ï¼Œå¦‚æœå…¨éƒ¨é’©å­æ‰§è¡Œå®Œäº†ï¼Œåˆ™å¯¼èˆªçš„çŠ¶æ€ä¼šå˜æˆ`confirmed`(ç¡®è®¤çš„)ã€‚

æœ€åå¯ä»¥çœ‹ä¸€ä¸‹`Vue-Router`é‡Œé¢å¯¹å¯¼èˆªçš„å®Œæ•´è§£ææµç¨‹ï¼š

> å¯¼èˆªè¢«è§¦å‘ã€‚
åœ¨å¤±æ´»çš„ç»„ä»¶é‡Œè°ƒç”¨ç¦»å¼€å®ˆå«ã€‚
è°ƒç”¨å…¨å±€çš„ beforeEach å®ˆå«ã€‚
åœ¨é‡ç”¨çš„ç»„ä»¶é‡Œè°ƒç”¨ beforeRouteUpdate å®ˆå« (2.2+)ã€‚
åœ¨è·¯ç”±é…ç½®é‡Œè°ƒç”¨ beforeEnterã€‚
è§£æå¼‚æ­¥è·¯ç”±ç»„ä»¶ã€‚
åœ¨è¢«æ¿€æ´»çš„ç»„ä»¶é‡Œè°ƒç”¨ beforeRouteEnterã€‚
è°ƒç”¨å…¨å±€çš„ beforeResolve å®ˆå« (2.5+)ã€‚
å¯¼èˆªè¢«ç¡®è®¤ã€‚
è°ƒç”¨å…¨å±€çš„ afterEach é’©å­ã€‚
è§¦å‘ DOM æ›´æ–°ã€‚
ç”¨åˆ›å»ºå¥½çš„å®ä¾‹è°ƒç”¨ beforeRouteEnter å®ˆå«ä¸­ä¼ ç»™ next çš„å›è°ƒå‡½æ•°ã€‚

#### æ€»ç»“
ä¼ ç»Ÿçš„è·¯ç”±å®ç°æ˜¯é€šè¿‡å¯¹è·¯å¾„çš„åˆ‡æ¢åšåˆ°çš„ï¼Œå¯¹äº`Vue-Router`è€Œè¨€ï¼Œè·¯ç”±æ¨¡å—çš„æœ¬è´¨ å°±æ˜¯å»ºç«‹èµ·urlå’Œé¡µé¢ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚è·¯ç”±å§‹ç»ˆä¼šç»´æŠ¤å½“å‰çš„çº¿è·¯ï¼Œè·¯ç”±åˆ‡æ¢çš„æ—¶å€™ä¼šæŠŠå½“å‰çº¿è·¯åˆ‡æ¢åˆ°ç›®æ ‡çº¿è·¯ï¼Œåˆ‡æ¢è¿‡ç¨‹ä¸­ä¼šæ‰§è¡Œä¸€ç³»åˆ—çš„å¯¼èˆªå®ˆå«é’©å­å‡½æ•°ï¼Œä¼šæ›´æ”¹`url`ï¼ŒåŒæ ·ä¹Ÿä¼šæ¸²æŸ“å¯¹åº”çš„ç»„ä»¶ï¼Œåˆ‡æ¢å®Œæ¯•åä¼šæŠŠç›®æ ‡çº¿è·¯æ›´æ–°æ›¿æ¢å½“å‰çº¿è·¯ï¼Œè¿™æ ·å°±ä¼šä½œä¸ºä¸‹ä¸€æ¬¡çš„è·¯å¾„åˆ‡æ¢çš„ä¾æ®.

å‚è€ƒé“¾æ¥ï¼š[Vueæ ¸å¿ƒè§£å¯†](https://ustbhuangyi.github.io/vue-analysis/vue-router/)
